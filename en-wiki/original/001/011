Euclidean algorithm

tagline From Wikipedia, the free encyclopedia /tagline subtitle /subtitle jumpto Jump to: navigation , search /jumpto bodycontent This article is about the greatest common divisor.  For the mathematics of space, see Euclidean geometry . Euclid's method for finding the greatest common divisor (GCD) of two starting lengths BA and DC, both defined to be multiples of a common "unit" length. The length DC being shorter, it is used to "measure" BA, but only once because remainder EA is less than CD. EA now measures (twice) the shorter length DC, with remainder FC shorter than EA. Then FC measures (three times) length EA. Because there is no remainder, the process ends with FC being the GCD. On the right Nicomachus ' example with numbers 49 and 21 resulting in their GCD of 7 (derived from Heath 1908:300). In mathematics , the Euclidean algorithm [a] (also called Euclid's algorithm ) is an efficient method for computing the greatest common divisor (GCD) of two integers, also known as the greatest common factor (GCF) or highest common factor (HCF). It is named after the Greek mathematician Euclid , who described it in Books VII and X of his Elements . [ 1 ] The earliest surviving description of the Euclidean algorithm is in Euclid's Elements (c. 300 BC), making it one of the oldest numerical algorithms still in common use. The original algorithm was described only for natural numbers and geometric lengths (real numbers), but the algorithm was generalized in the 19th century to other types of numbers, such as Gaussian integers and polynomials in one variable. This led to modern abstract algebraic notions such as Euclidean domains . The Euclidean algorithm has been generalized further to other mathematical structures, such as knots and multivariate polynomials . The algorithm has many theoretical and practical applications. It may be used to generate almost all the most important traditional musical rhythms used in different cultures throughout the world. [ 2 ] It is a key element of the RSA algorithm , a public-key encryption method widely used in electronic commerce . It is used to solve Diophantine equations , such as finding numbers that satisfy multiple congruences ( Chinese remainder theorem ) or multiplicative inverses of a finite field . It can also be used to construct continued fractions , in the Sturm chain method for finding real roots of a polynomial, and in several modern integer factorization algorithms. Finally, it is a basic tool for proving theorems in modern number theory , such as Lagrange's four-square theorem and the fundamental theorem of arithmetic (unique factorization). If implemented using remainders of long division rather than subtractions, Euclid's algorithm computes the GCD of large numbers efficiently: it never requires more division steps than five times the number of digits (base 10) of the smaller integer. This was proved by Gabriel Lamé in 1844, and marks the beginning of computational complexity theory . Methods for improving the algorithm's efficiency were developed in the 20th century. The GCD of two numbers is the largest number that divides both of them without leaving a remainder . The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the smaller number is subtracted from the larger number. For example, 21 is the GCD of 252 and 105 (252 = 21 × 12; 105 = 21 × 5); since 252 − 105 = 147, the GCD of 147 and 105 is also 21. Since the larger of the two numbers is reduced, repeating this process gives successively smaller numbers until one of them is zero. When that occurs, the GCD is the remaining nonzero number. By reversing the steps in the Euclidean algorithm , the GCD can be expressed as a sum of the two original numbers each multiplied by a positive or negative integer , e.g., 21 = [5 × 105] + [(−2) × 252]. This important property is known as Bézout's identity . Contents 1 Concrete example 2 Background 2.1 Greatest common divisor 2.2 Induction, recursion and infinite descent 3 Description 3.1 Procedure 3.2 Proof of validity 3.3 Worked example 3.4 Visualization 3.5 Calculating the quotients and remainders 3.6 Implementations 3.7 Method of least absolute remainders 4 Historical development 5 Mathematical applications 5.1 Bézout's identity 5.2 Principal ideals and related problems 5.3 Extended Euclidean algorithm 5.4 Matrix method 5.5 Euclid's lemma and unique factorization 5.6 Linear Diophantine equations 5.7 Multiplicative inverses and the RSA algorithm 5.8 Chinese remainder theorem 5.9 Stern–Brocot Tree 5.10 Continued fractions 5.11 Factorization algorithms 6 Algorithmic efficiency 6.1 Number of steps 6.1.1 Worst-case number of steps 6.1.2 Average number of steps 6.2 Computational expense per step 6.3 Efficiency of alternative methods 7 Other number systems 7.1 Rational and real numbers 7.2 Polynomials 7.3 Gaussian integers 7.4 Euclidean domains 7.4.1 Unique factorization of quadratic integers 7.5 Noncommutative rings 8 Generalizations to other mathematical structures 9 See also 10 Notes 11 References 12 Bibliography 13 External links [ edit ] Concrete example Suppose it is desired to find gcd(1989, 867), i.e. the greatest common divisor of 1989 and 867. If we reduce the larger number by subtracting the smaller one from it, the gcd does not change: So subtract again: Now 867 is no longer the smaller number. Continuing in the same way, we reduce the larger number, now 867, by subtracting the smaller one from it, leaving the gcd unchanged: The first number, 255, is still the smaller one, so again we use it to reduce the larger one: Now 255 is the larger number and we reduce it by subtracting 102 from it: Now 102 is the larger one and we reduce it by subtracting 51 from it: Now we are done: we conclude that gcd(1989,867) = 51. Thus we must have By division, we get When one repeatedly reduces the larger number by subtracting the smaller one from it, thus: then the smallest number at the end, 255, is the remainder that results from dividing 1989 by 867. Thus the algorithm is often described as follows: Given the problem of finding gcd(1989,867), one replaces the larger number, 1989, by the remainder that results from dividing it by the smaller number, 867, getting Next one replaces the larger number, 867, by the remainder that results from dividing it by the now-smaller number, 255, getting Next one replaces the larger number, 255, by the remainder that results from dividing it by the now-smaller number, 102, getting Next one replaces the larger number, 102, by the remainder that results from dividing it by the now-smaller number, 51, getting When 0 appears, we are done; the gcd is 51. [ edit ] Background [ edit ] Greatest common divisor Main article: Greatest common divisor The Euclidean algorithm calculates the greatest common divisor (GCD) of two natural numbers a and b . The greatest common divisor g is the largest natural number that divides both a and b without leaving a remainder. Synonyms for the GCD include the greatest common factor (GCF), the highest common factor (HCF), and the greatest common measure (GCM). The greatest common divisor is often written as GCD( a , b ) or, more simply, as ( a , b ), [ 3 ] although the latter notation is also used for other mathematical concepts, such as two-dimensional vectors . If GCD( a , b ) = 1, then a and b are said to be coprime (or relatively prime). [ 4 ] This property does not imply that a or b are themselves prime numbers . [ 5 ] For example, neither 6 nor 35 is a prime number, since they both have two prime factors: 6 = 2 × 3 and 35 = 5 × 7. Nevertheless, 6 and 35 are coprime. No natural number other than 1 divides both 6 and 35, since they have no prime factors in common. A 24-by-60 rectangle is covered with ten 12-by-12 square tiles, where 12 is the GCD of 24 and 60. More generally, an a -by- b rectangle can be covered with square tiles of side-length c only if c is a common divisor of a and b . Let g = GCD( a , b ). Since a and b are both multiples of g , they can be written a = mg and b = ng , and there is no larger number G > g for which this is true. The natural numbers m and n must be coprime, since any common factor can be factored out of m and n to make g greater. Thus, any other number c that divides both a and b must also divide g . The greatest common divisor g of a and b is the unique (positive) common divisor of a and b that is divisible by any other common divisor c . [ 6 ] The GCD can be visualized as follows. [ 7 ] Consider a rectangular area a by b , and any common divisor c that divides both a and b exactly. The sides of the rectangle can be divided into segments of length c , which divides the rectangle into a grid of squares of side length c . The greatest common divisor g is the largest value of c for which this is possible. For illustration, a 24-by-60 rectangular area can be divided into a grid of: 1-by-1 squares, 2-by-2 squares, 3-by-3 squares, 4-by-4 squares, 6-by-6 squares or 12-by-12 squares. Therefore, 12 is the greatest common divisor of 24 and 60. A 24-by-60 rectangular area can be divided into a grid of 12-by-12 squares, with two squares along one edge (24/12 = 2) and five squares along the other (60/12 = 5). The GCD of two numbers a and b is the product of the prime factors shared by the two numbers, where a same prime factor can be used multiple times, but only as long as the product of these factors divides both a and b . [ 8 ] For example, since 1386 can be factored into 2 × 3 × 3 × 7 × 11, and 3213 can be factored into 3 × 3 × 3 × 7 × 17, the greatest common divisor of 1386 and 3213 equals 63 = 3 × 3 × 7, the product of their shared prime factors. If two numbers have no prime factors in common, their greatest common divisor is 1 (obtained here as an instance of the empty product ), in other words they are coprime. A key advantage of the Euclidean algorithm is that it can find the GCD efficiently without having to compute the prime factors. [ 9 ] [ 10 ] Factorization of large integers is believed to be a computationally very difficult problem, and the security of many modern cryptography systems is based upon its infeasibility. [ 11 ] Another definition of the GCD is helpful in advanced mathematics, particularly ring theory . [ 12 ] The greatest common divisor g of two nonzero numbers a and b is also their smallest positive integral linear combination, that is, the smallest positive number of the form ua + vb where u and v are integers. The set of all integral linear combinations of a and b is actually the same as the set of all multiples of g ( mg , where m is an integer). In modern mathematical language, the ideal generated by a and b is the ideal generated by g alone (an ideal generated by a single element is called a principal ideal , and all ideals of the integers are principal ideals). Some properties of the GCD are in fact easier to see with this description, for instance the fact that any common divisor of a and b also divides the GCD (it divides both terms of ua + vb ). The equivalence of this GCD definition with the other definitions is described below. The GCD of three or more numbers equals the product of the prime factors common to all the numbers, [ 13 ] but it can also be calculated by repeatedly taking the GCDs of pairs of numbers. [ 14 ] For example, GCD( a , b , c ) = GCD( a , GCD( b , c )) = GCD(GCD( a , b ), c ) = GCD(GCD( a , c ), b ). Thus, Euclid's algorithm, which computes the GCD of two integers, suffices to calculate the GCD of arbitrarily many integers. [ edit ] Induction, recursion and infinite descent Three related mathematical methods are used in the arguments below: induction , recursion and infinite descent . Induction [ 15 ] is often used to prove a theorem for all natural numbers n . [ 16 ] This approach begins by showing that, if the theorem holds for n , it also holds for n + 1. Therefore, if the theorem holds for one case (typically, n = 1), it holds for all higher cases ( n = 2, 3, etc.). A recursion [ 17 ] is an equation relating numbers that form a series a 1 , a 2 , a 3 , etc. [ 18 ] The n -th term in the series, a n , is often expressed in terms of earlier terms of the series, such as a n −1 . For example, the Fibonacci numbers are defined recursively; each term is the sum of the two preceding terms: F n = F n −1 + F n −2 . Several equations associated with the Euclidean algorithm are recursive. Finally, in infinite descent, [ 19 ] a given solution in natural numbers is used to construct a solution with smaller natural numbers. [ 20 ] However, the solutions cannot shrink indefinitely, since there are only a finite number of natural numbers below the initial natural numbers. Therefore, either the original solution was impossible, or the construction of smaller solutions must end. The latter argument is used to show that the Euclidean algorithm for natural numbers must end in a finite number of steps. [ 21 ] [ edit ] Description [ edit ] Procedure The Euclidean algorithm is iterative, meaning that the answer is found in a series of steps; the output of each step is used as an input for the next step. [ 22 ] Let k be an integer that counts the steps of the algorithm, starting with zero. Thus, the initial step corresponds to k = 0, the next step corresponds to k = 1, and so on. Each step begins with two nonnegative remainders r k −1 and r k −2 . Since the algorithm ensures that the remainders decrease steadily with every step, r k −1 is less than its predecessor r k −2 . The goal of the k th step is to find a quotient q k and remainder r k such that the equation is satisfied r k −2 = q k r k −1 + r k where r k < r k −1 . In other words, multiples of the smaller number r k −1 are subtracted from the larger number r k −2 until the remainder is smaller than the r k −1 . In the initial step ( k = 0), the remainders r −2 and r −1 equal a and b , the numbers for which the GCD is sought. In the next step ( k = 1), the remainders equal b and the remainder r 0 of the initial step, and so on. Thus, the algorithm can be written as a sequence of equations a = q 0 b + r 0 b = q 1 r 0 + r 1 r 0 = q 2 r 1 + r 2 r 1 = q 3 r 2 + r 3 … If a is smaller than b , the first step of the algorithm swaps the numbers. For example, if a < b , the initial quotient q 0 equals zero, and the remainder r 0 is a . Thus, r k is smaller than its predecessor r k −1 for all k ≥ 0. Since the remainders decrease with every step but can never be negative, a remainder r N must eventually equal zero, at which point the algorithm stops. [ 21 ] The final nonzero remainder r N −1 is the greatest common divisor of a and b . The number N cannot be infinite because there are only a finite number of nonnegative integers between the initial remainder r 0 and zero. [ edit ] Proof of validity The validity of the Euclidean algorithm can be proven by a two-step argument. [ 22 ] In the first step, the final nonzero remainder r N −1 is shown to divide both a and b . Since it is a common divisor, it must be less than or equal to the greatest common divisor g . In the second step, it is shown that any common divisor of a and b , including g , must divide r N −1 ; therefore, g must be less than or equal to r N −1 . These two conclusions are inconsistent unless r N −1 = g . To demonstrate that r N −1 divides both a and b (the first step), r N −1 divides its predecessor r N −2 r N −2 = q N r N −1 since the final remainder r N is zero. r N −1 also divides its next predecessor r N −3 r N −3 = q N −1 r N −2 + r N −1 because it divides both terms on the right-hand side of the equation. Iterating the same argument, r N −1 divides all the preceding remainders, including a and b . None of the preceding remainders r N −2 , r N −3 , etc. divide a and b , since they leave a remainder. Since r N −1 is a common divisor of a and b , r N −1 ≤ g . In the second step, any natural number c that divides both a and b (in other words, any common divisor of a and b ) divides the remainders r k . By definition, a and b can be written as multiples of c : a = mc and b = nc , where m and n are natural numbers. Therefore, c divides the initial remainder r 0 , since r 0 = a − q 0 b = mc − q 0 nc = ( m − q 0 n ) c . An analogous argument shows that c also divides the subsequent remainders r 1 , r 2 , etc. Therefore, the greatest common divisor g must divide r N −1 , which implies that g ≤ r N −1 . Since the first part of the argument showed the reverse ( r N −1 ≤ g ), it follows that g = r N −1 . Thus, g is the greatest common divisor of all the succeeding pairs: [ 23 ] [ 24 ] g = GCD( a , b ) = GCD( b , r 0 ) = GCD( r 0 , r 1 ) = … = GCD( r N −2 , r N −1 ) = r N −1 . [ edit ] Worked example Animation of the algorithm. The initial green rectangle has dimensions a = 1071 and b = 462. Square 462×462 tiles (yellow) are added until a green 462×147 rectangle remains. This is tiled with square 147×147 tiles (blue) until a 21×147 rectangle remains. This third rectangle is tiled with 21×21 square tiles (red), leaving no remainder. Thus, 21 is the greatest common divisor of 1071 and 462. For illustration, the Euclidean algorithm can be used to find the greatest common divisor of a = 1071 and b = 462. To begin, multiples of 462 are subtracted from 1071 until the remainder is less than 462. Two such multiples can be subtracted ( q 0 = 2), leaving a remainder of 147 1071 = 2 × 462 + 147. Then multiples of 147 are subtracted from 462 until the remainder is less than 147. Three multiples can be subtracted ( q 1 = 3), leaving a remainder of 21 462 = 3 × 147 + 21. Then multiples of 21 are subtracted from 147 until the remainder is less than 21. Seven multiples can be subtracted ( q 2 = 7), leaving no remainder 147 = 7 × 21 + 0. Since the last remainder is zero, the algorithm ends with 21 as the greatest common divisor of 1071 and 462. This agrees with the GCD(1071, 462) found by prime factorization above . In tabular form, the steps are Step k Equation Quotient and remainder 0 1071 = q 0 462 + r 0 q 0 = 2 and r 0 = 147 1 462 = q 1 147 + r 1 q 1 = 3 and r 1 = 21 2 147 = q 2 21 + r 2 q 2 = 7 and r 2 = 0; algorithm ends [ edit ] Visualization The Euclidean algorithm can be visualized in terms of the tiling analogy given above for the greatest common divisor. [ 25 ] Assume that we wish to cover an a -by- b rectangle with square tiles exactly, where a is the larger of the two numbers. We first attempt to tile the rectangle using b -by- b square tiles; however, this leaves an r 0 -by- b residual rectangle untiled, where r 0 < b . We then attempt to tile the residual rectangle with r 0 -by- r 0 square tiles. This leaves a second residual rectangle r 1 -by- r 0 , which we attempt to tile using r 1 -by- r 1 square tiles, and so on. The sequence ends when there is no residual rectangle, i.e., when the square tiles cover the previous residual rectangle exactly. The length of the sides of the smallest square tile is the GCD of the dimensions of the original rectangle. For example, the smallest square tile in the adjacent figure is 21-by-21 (shown in red), and 21 is the GCD of 1071 and 462, the dimensions of the original rectangle (shown in green). [ edit ] Calculating the quotients and remainders See also: Modulo operation and Division algorithm At every step k , the Euclidean algorithm computes a quotient q k and remainder r k from two numbers r k −1 and r k −2 r k −2 = q k r k −1 + r k where the magnitude of r k is strictly less than that of r k −1 . The division algorithm ensures that such a quotient and remainder always exist. The division algorithm for natural numbers also states that q k and r k are unique, but that is not needed for the Euclidean algorithm. [ 26 ] In Euclid's original version of the algorithm, the quotient and remainder are found by repeated subtraction; that is, r k −1 is subtracted from r k −2 repeatedly until the remainder r k is smaller than r k −1 . A more efficient approach uses integer division and the modulo operation to calculate the quotient and remainder, respectively. The modulo operation gives the remainder after dividing two numbers; thus, r k ≡ r k −2 mod r k −1 The remainder is equivalent to the congruence class in modular arithmetic . [ edit ] Implementations Implementations of the algorithm may be expressed in pseudocode . For example, the division-based version may be programmed as [ 27 ] function gcd(a, b) while b ≠ 0